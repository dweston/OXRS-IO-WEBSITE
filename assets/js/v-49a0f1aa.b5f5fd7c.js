"use strict";(self.webpackChunkoxrs_docs_site=self.webpackChunkoxrs_docs_site||[]).push([[5908],{8715:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-49a0f1aa",path:"/docs/libraries/esp32-io-handler-library.html",title:"ESP32 I/O handler library",lang:"en-US",frontmatter:{tags:["OXRS-SHA-IOHandler-ESP32-LIB","TAG2","TAG3"]},excerpt:"",headers:[{level:2,title:"Introduction",slug:"introduction",children:[{level:3,title:"How does it work?",slug:"how-does-it-work",children:[]},{level:3,title:"USM_Input.h",slug:"usm-input-h",children:[]},{level:3,title:"USM_Output.h",slug:"usm-output-h",children:[]}]},{level:2,title:"Configuration",slug:"configuration",children:[{level:3,title:"USM_Input.h",slug:"usm-input-h-1",children:[]},{level:3,title:"USM_Output.h",slug:"usm-output-h-1",children:[]}]},{level:2,title:"Downloads",slug:"downloads",children:[]},{level:2,title:"Supported Hardware",slug:"supported-hardware",children:[]}],filePathRelative:"docs/libraries/esp32-io-handler-library.md",git:{updatedTime:1637554465e3,contributors:[{name:"Aaron Knox",email:"aaron_knox@me.com",commits:2},{name:"Ben Jones",email:"ben.jones12@gmail.com",commits:1},{name:"austinscreations",email:"70245481+austinscreations@users.noreply.github.com",commits:1},{name:"ben",email:"ben.jones12@gmail.com",commits:1}]}}},2988:(n,s,a)=>{a.r(s),a.d(s,{default:()=>A});var e=a(6252);const t=(0,e.uE)('<h1 id="esp32-i-o-handler-library" tabindex="-1"><a class="header-anchor" href="#esp32-i-o-handler-library" aria-hidden="true">#</a> ESP32 I/O handler library</h1><p class="maker">by <b>SuperHouse Automation</b></p><blockquote><p>SKU: OXRS-SHA-IOHandler-ESP32-LIB</p></blockquote><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p>This library serves two functions, for input monitoring and output control. It can monitor buttons, switches, contacts, or any binary sensor, and report events back to the caller. It can also listen for binary commands and passes control events back to the caller.</p><p>Typically used with MCP23017 I2C I/O buffers to detect digital signals being pulled to GND (inputs) and to control relays (outputs).</p><hr><h3 id="how-does-it-work" tabindex="-1"><a class="header-anchor" href="#how-does-it-work" aria-hidden="true">#</a> How does it work?</h3><p>The library contains two classes which can be used independently or together, depending on what your firmware is trying to do.</p><h3 id="usm-input-h" tabindex="-1"><a class="header-anchor" href="#usm-input-h" aria-hidden="true">#</a> <code>USM_Input.h</code></h3><p>Monitors and maintains state for up to 16 inputs. Takes 16 bits of binary data and checks each value against an internal state machine to determine if any input events have occurred.</p><h3 id="usm-output-h" tabindex="-1"><a class="header-anchor" href="#usm-output-h" aria-hidden="true">#</a> <code>USM_Output.h</code></h3><p>Waits for commands and generates control events for up to 16 outputs. Keeps track of output state and handles interlocking and timers.</p><h2 id="configuration" tabindex="-1"><a class="header-anchor" href="#configuration" aria-hidden="true">#</a> Configuration</h2><h3 id="usm-input-h-1" tabindex="-1"><a class="header-anchor" href="#usm-input-h-1" aria-hidden="true">#</a> <code>USM_Input.h</code></h3><p>Each of the 16 inputs can be configured as either <code>BUTTON</code>, <code>CONTACT</code>, <code>ROTARY</code>, <code>SWITCH</code> or <code>TOGGLE</code>. Different events will be generated depending on the configured type, and the sequence of state changes.</p><p>Each of the 16 inputs can also be inverted, so events are generated on <code>LOW</code> -&gt; <code>HIGH</code> transitions instead of <code>HIGH</code> -&gt; <code>LOW</code>.</p><h4 id="rotary-encoders" tabindex="-1"><a class="header-anchor" href="#rotary-encoders" aria-hidden="true">#</a> Rotary Encoders</h4>',18),p=(0,e.Uk)("A pair of inputs can be set as "),o=(0,e._)("code",null,"ROTARY",-1),c=(0,e.Uk)(" inputs, and connected to an "),r={href:"https://lastminuteengineers.com/rotary-encoder-arduino-tutorial/",target:"_blank",rel:"noopener noreferrer"},l=(0,e.Uk)("incremental rotary encoder"),i=(0,e.Uk)(". The library will decode the signals from the encoder and generate "),u=(0,e._)("code",null,"LOW_EVENT",-1),d=(0,e.Uk)(" or "),h=(0,e._)("code",null,"HIGH_EVENT",-1),m=(0,e.Uk)(" events, depending which way the encoder is turned."),k=(0,e.uE)('<h4 id="functions" tabindex="-1"><a class="header-anchor" href="#functions" aria-hidden="true">#</a> Functions</h4><ul><li><code>setType(input, type)</code>: Set the input type</li><li><code>setInvert(input, invert)</code>: Invert input handling</li></ul><h4 id="code-example" tabindex="-1"><a class="header-anchor" href="#code-example" aria-hidden="true">#</a> Code Example</h4><div class="language-cpp ext-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Adafruit_MCP23X17.h&gt;</span>        <span class="token comment">// For MCP23017 I/O buffers</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;OXRS_Input.h&gt;</span>               <span class="token comment">// For input handling</span></span>\n\n<span class="token comment">// I/O buffers</span>\nAdafruit_MCP23X17 mcp23017<span class="token punctuation">;</span>\n\n<span class="token comment">// Input handlers</span>\nOXRS_Input oxrsInput<span class="token punctuation">;</span>\n\n<span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Initialise the MCP chip (assume at address 0x20)</span>\n  mcp23017<span class="token punctuation">.</span><span class="token function">begin_I2C</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Set every pin to be INPUT with internal PULLUPs enabled</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> pin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pin <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> pin<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    mcp23017<span class="token punctuation">.</span><span class="token function">pinMode</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> INPUT_PULLUP<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token comment">// Initialise the input handler</span>\n  oxrsInput<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span>inputEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Configurate types and invert state here</span>\n  <span class="token comment">//oxrsInput.setType(0, BUTTON);</span>\n  <span class="token comment">//oxrsInput.setInvert(0, 1);</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Read the values for all 16 inputs on this MCP in one hit</span>\n  <span class="token keyword">uint16_t</span> io_value <span class="token operator">=</span> mcp23017<span class="token punctuation">.</span><span class="token function">readGPIOAB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Check for any input events</span>\n  oxrsInput<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> io_value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">void</span> <span class="token function">inputEvent</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> id<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> input<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> type<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Code to handle the event goes in here!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h3 id="usm-output-h-1" tabindex="-1"><a class="header-anchor" href="#usm-output-h-1" aria-hidden="true">#</a> <code>USM_Output.h</code></h3><p>Each of the 16 outputs can be configured as either <code>MOTOR</code>, <code>RELAY</code>, or <code>TIMER</code>. Different control signals will be generated depending on the configured type.</p><h4 id="interlocking" tabindex="-1"><a class="header-anchor" href="#interlocking" aria-hidden="true">#</a> Interlocking</h4><p>Interlocking two outputs allows them to control equipment such as roller blinds, garage doors, louvre roofing etc.</p><p>If two outputs are interlocked it means they can&#39;t be <code>on</code> at the same time. E.g. if output A and B are interlocked, and an <code>on</code> command is sent to output B while output A is <code>on</code>, output A will automatically turn <code>off</code> and after a short delay output B will then turn <code>on</code>.</p><h4 id="timers" tabindex="-1"><a class="header-anchor" href="#timers" aria-hidden="true">#</a> Timers</h4><p>Timers allow an output to automatically turn <code>off</code> a set number of seconds after being turned <code>on</code> (configurable but defaults to 60 seconds).</p><p>If another <code>on</code> command is sent while the timer is running, it will reset to zero and begin counting down again. If an <code>off</code> command is sent the timer will be cancelled and the output turned <code>off</code> immediately.</p><h4 id="functions-1" tabindex="-1"><a class="header-anchor" href="#functions-1" aria-hidden="true">#</a> Functions</h4><ul><li><code>setType(output, type)</code>: Set the output type</li><li><code>setInterlock(output, interlock)</code>: Interlock an output with another</li><li><code>setTimer(output, seconds)</code>: Set the timer duration (in seconds)</li></ul><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>The only difference between <code>MOTOR</code> and <code>RELAY</code> outputs is the interlock delay. For <code>MOTOR</code> outputs the delay is 2000ms, for <code>RELAY</code> outputs it is only 500ms.</p></div><h4 id="code-example-1" tabindex="-1"><a class="header-anchor" href="#code-example-1" aria-hidden="true">#</a> Code Example</h4><div class="language-cpp ext-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;Adafruit_MCP23X17.h&gt;</span>        <span class="token comment">// For MCP23017 I/O buffers</span></span>\n<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;OXRS_Output.h&gt;</span>              <span class="token comment">// For output handling</span></span>\n\n<span class="token comment">// I/O buffers</span>\nAdafruit_MCP23X17 mcp23017<span class="token punctuation">;</span>\n\n<span class="token comment">// Input handlers</span>\nOXRS_Output oxrsOutput<span class="token punctuation">;</span>\n\n<span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Initialise the MCP chip (assume at address 0x20)</span>\n  mcp23017<span class="token punctuation">.</span><span class="token function">begin_I2C</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Set every pin to OUTPUT</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> pin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pin <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> pin<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    mcp23017<span class="token punctuation">.</span><span class="token function">pinMode</span><span class="token punctuation">(</span>pin<span class="token punctuation">,</span> OUTPUT<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token comment">// Initialise the output handler</span>\n  oxrsOutput<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span>outputEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Configurate types, interlocks and timers here</span>\n  <span class="token comment">//oxrsOutput.setInterlock(0, 1);</span>\n  <span class="token comment">//oxrsOutput.setInterlock(1, 0);</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Check for any output events</span>\n  oxrsOutput<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Need a way to receive commands - e.g. serial input or MQTT messages</span>\n  <span class="token comment">//oxrsOutput.handleCommand(0, output, RELAY_ON);</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">void</span> <span class="token function">outputEvent</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> id<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> output<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> type<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Code to handle the event goes in here!</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h2 id="downloads" tabindex="-1"><a class="header-anchor" href="#downloads" aria-hidden="true">#</a> Downloads</h2>',18),b=(0,e.Uk)("Download the latest version of the firmware on "),f={href:"https://github.com/SuperHouse/OXRS-SHA-IOHandler-ESP32-LIB",target:"_blank",rel:"noopener noreferrer"},g=(0,e.Uk)("Github"),y=(0,e.Uk)("."),w=(0,e._)("h2",{id:"supported-hardware",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#supported-hardware","aria-hidden":"true"},"#"),(0,e.Uk)(" Supported Hardware")],-1),v=(0,e._)("p",null,"Designed to run on ESP32 based devices.",-1),_=(0,e.Uk)("Rack32"),I=(0,e._)("hr",null,null,-1),O=(0,e._)("h4",{id:"credits",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#credits","aria-hidden":"true"},"#"),(0,e.Uk)(" Credits")],-1),x={href:"https://oxrs.io/",target:"_blank",rel:"noopener noreferrer"},S=(0,e.Uk)("OXRS"),T=(0,e.Uk)(" Core Team"),U=(0,e._)("hr",null,null,-1),C=(0,e._)("h4",{id:"license",tabindex:"-1"},[(0,e._)("a",{class:"header-anchor",href:"#license","aria-hidden":"true"},"#"),(0,e.Uk)(" License")],-1),E=(0,e.Uk)("Found "),P={href:"https://github.com/SuperHouse/OXRS-SHA-IOHandler-ESP32-LIB/blob/main/LICENSE",target:"_blank",rel:"noopener noreferrer"},M=(0,e.Uk)("here"),R=(0,e.Uk)("."),A={render:function(n,s){const a=(0,e.up)("OutboundLink"),A=(0,e.up)("RouterLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[t,(0,e._)("p",null,[p,o,c,(0,e._)("a",r,[l,(0,e.Wm)(a)]),i,u,d,h,m]),k,(0,e._)("p",null,[b,(0,e._)("a",f,[g,(0,e.Wm)(a)]),y]),w,v,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e.Wm)(A,{to:"/docs/hardware/controllers/rack32.html"},{default:(0,e.w5)((()=>[_])),_:1})])]),I,O,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("a",x,[S,(0,e.Wm)(a)]),T])]),U,C,(0,e._)("p",null,[E,(0,e._)("a",P,[M,(0,e.Wm)(a)]),R])],64)}}}}]);